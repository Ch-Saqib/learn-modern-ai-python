[Lesson 01: Introduction to Python](https://colab.research.google.com/drive/1LqRMqVAff7jR_Xha7arxwHkFdQL08xAu?usp=sharing)


"""Agentic AI - Python - Lesson 01 - Introduction to Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LqRMqVAff7jR_Xha7arxwHkFdQL08xAu

<font color="#a9a56c" size=2> **@Author: Arif Kasim Rozani - (Team Operation Badar)** </font>

## **Useful Links:**

- [Download Python](https://www.python.org/downloads/)
- [Python 3.13.2 documentation](https://docs.python.org/3/index.html)
- [www.w3schools.com](https://www.w3schools.com/python/default.asp)
- [www.tutorialspoint.com](https://www.tutorialspoint.com/python/index.htm)
- [code.visualstudio.com](https://code.visualstudio.com/download)
- [www.cursor.com](https://www.cursor.com/downloads)

# **Python: The Versatile and Powerful Programming Language**

Python is a `high-level`, `interpreted`, and versatile programming language known for its simplicity and readability. Created by Guido van Rossum, it emphasizes code clarity and supports multiple `programming paradigms` like `procedural`, `object-oriented`, and `functional programming`. Pythonâ€™s extensive standard library and community support make it ideal for web development, data analysis, AI, automation, and more. Its cross-platform compatibility and beginner-friendly syntax have made it one of the most popular languages worldwide.

# **Python in Agentic AI: Powering Autonomous Intelligence** ðŸš€

Python plays a crucial role in `Agentic AI`, enabling `autonomous agents` to `perceive`, `reason`, and `act`. With frameworks like LangChain, CrewAI, Microsoft AutoGen, Auto-GPT, and OpenAI's APIs, Python facilitates `LLM-driven workflows`, `decision-making`, and `self-improving AI`. Its rich ecosystem supports seamless integration of `NLP - Natural language processing`, `reinforcement learning`, and `automation` for building intelligent, agentic systems.

# **Practical Applications of Python**

Python has numerous practical applications across various industries. Some of the top applications include:

* **Data Science and Analytics**: data analysis, machine learning, and visualization

* **Agentic AI**: building autonomous agents, chatbots, and virtual assistants
* **Machine Learning**: developing predictive models and recommender systems
* **Natural Language Processing (NLP)**: text analysis, sentiment analysis, and language translation
* **Computer Vision**: image recognition, object detection, and facial recognition
* **Robotics**: building and controlling robots, drones, and autonomous vehicles
* **Web Development**: building web applications and frameworks
* **Artificial Intelligence and Machine Learning**: AI, ML, and deep learning
* **Automation and Scripting**: automating tasks and workflows
* **Scientific Computing**: scientific simulations and data analysis
* **Cybersecurity**: security testing and penetration testing
* **Internet of Things (IoT)**: building IoT applications and devices


These applications make Python a versatile and in-demand language in the industry. Its simplicity, flexibility, and extensive libraries make it a popular choice for developers and data scientists.


Python's simplicity and extensive libraries make it an ideal choice for building **Agentic AI** applications that can interact, learn, and adapt to their environments.

## **The Code Execution Continuum: A Comprehensive Exploration of Computer Languages from Code Writing to Runtime and Output**

Delve into the code execution continuum(*`continuation`, `chain`*), exploring how computer languages transform from source code to bytecode, runtime, and output. Discover the complex journey of code compilation, interpretation, and execution, revealing the inner workings of programming languages and their role in modern computing.

## **Exercise: Generating Our First Python Code**

Write a Python program that uses indentation to define a block of code within an if statement. Use consistent indentation and follow the rules outlined above.

1.  Click on `+Code`, a code cell will appear
2.  In the code cell its written "Start coding or <ins>generate</ins> with AI"
3.  Click on "generate"
4.  Copy the prompt: `Write a Python program that uses indentation to define a block of code within an if statement. Use consistent indentation and follow the rules outlined above`
5.  Paste it in Generate text bar.
6.  Click on Generate button or press enter
"""



"""## **Python is a Dynamically-Typed Language with Optional Type Hinting**

Python is a dynamically-typed language, which means that it does not enforce the data type of a variable at compile time. Instead, the data type is determined at runtime.

However, Python 3.5 and later versions also support optional type hinting, which allows developers to add type annotations to their code to specify the expected types of variables, function parameters, and return types.
"""

age: int = input("Enter your age: ")
print(f"Your age is {age}")

print("type(age) = ", type(age))

"""**Key Characteristics:**

1. **Dynamically-Typed**: Python's data type is determined at runtime, not at compile time.

2. **Optional Type Hinting**: Type hinting is optional, but it can help with code readability, auto-completion, and static type checking.
3. **No Compile-Time Type Checking**: Python does not perform type checking at compile time, but it can be done using third-party tools or IDEs.

**Why Use Type Hints?**

Type hints are useful for several reasons:

* **Improved Code Readability**: Type hints make it clear what types of data your code is intended to work with, making it easier for others (and yourself) to understand your code.

* **Better Code Completion**: Many IDEs and text editors can use type hints to provide more accurate code completion suggestions, making it easier to write code.
* **Static Type Checking**: Type hints can be used by static type checking tools to identify potential type-related errors before your code is even run.
* **Improved Documentation**: Type hints can serve as a form of documentation, making it clear what types of data your code expects and returns.

**Basic Syntax**

The basic syntax for type hinting is to add a colon (:) followed by the expected type after the variable or function parameter. For example:
```python
x: int = 5
y: str = "hello"
```
**Function Type Hints**

You can also add type hints to function parameters and return types using the following syntax:
```python
def greet(name: str) -> str:
    return "Hello, " + name + "!"
```
In this example, the `greet` function takes a `name` parameter of type `str` and returns a value of type `str`.


**Type Hinting for Complex Types**

You can also use type hinting for more complex types, such as lists, dictionaries, and tuples. For example:
```python
my_list: list[int] = [1, 2, 3]
my_dict: dict[str, int] = {"a": 1, "b": 2}
my_tuple: tuple[str, int] = ("hello", 5)
```

**Best Practices**

* Use type hints consistently throughout your code.

* Use the most specific type possible (e.g., `int` instead of `Any`).
* Use type hints for function parameters and return types.
* Use type hints for complex types, such as lists and dictionaries.

## **Object-Based Language vs. Object-Oriented Language**


---

## **Object-Based Language:**

- **Definition**:

  An object-based language is a programming language that supports the concept of objects but does not fully implement all the features of object-oriented programming (OOP). This means that while you can create and manipulate objects, you may not have full support for features like inheritance, polymorphism, and encapsulation.


- **Characteristics**:

  - Supports objects and encapsulation.
  - Does not necessarily support inheritance or polymorphism.
  - Examples include JavaScript (prior to ES6), VBScript, and some versions of Pascal.


- **Use Cases**:

  Object-based languages are often used for scripting and simple applications where full OOP features are not required.

## **Object-Oriented Language:**

- **Definition**:

  An object-oriented language is a programming language that fully supports the principles of object-oriented programming, including encapsulation, inheritance, and polymorphism. This allows for more complex and reusable code structures.


- **Characteristics**:

  - Supports encapsulation (hiding data and methods within objects).
  - Supports inheritance (creating new classes based on existing ones).
  - Supports polymorphism (using a single interface to represent different underlying forms).
  - Examples include Python, Java, C++, and Ruby.

- **Use Cases**:

  Object-oriented languages are widely used in software development for building large, complex systems, as they promote code reuse and modularity.

## **Summary of Differences**


| Feature | Object-Based Language | Object-Oriented Language |
|------------------------|-------------------------------------|-------------------------------------|
| Encapsulation | Supported | Supported |
| Inheritance | Not necessarily supported | Fully supported |
| Polymorphism | Not necessarily supported | Fully supported |
| Examples | JavaScript (pre-ES6), VBScript | Python, Java, C++, Ruby |

## **The Python's Object-Centric Nature**


Python as an Object-Centric Language:


- **Everything is an Object**:

  In Python, everything is treated as an object, including primitive data types like integers, strings, and lists. This means that all data types in Python have associated methods and properties, allowing for a consistent and unified approach to programming.
"""

# Example of integers as objects
x: int = 100
print(x.bit_length())  # Method call on an integer object

"""- **First-Class Functions**:

  Functions in Python are first-class objects, meaning they can be passed as arguments, returned from other functions, and assigned to variables. This allows for functional programming paradigms alongside object-oriented programming.
"""

def greet(name) -> str:
    return f"Hello, {name}!"

def call_function(func, name) -> str:
    return func(name)

print(call_function(greet, "Alice"))  # Passing a function as an argument

"""- **Support for OOP Principles**:

  Python fully supports object-oriented programming principles, including encapsulation, inheritance, and polymorphism. You can define classes, create objects, and use inheritance to create new classes based on existing ones.
"""

class Animal:
    def speak(self) -> str:
        return "Animal speaks"

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

class Lion(Animal):
    def speak(self) -> str:
        return "Roar!"


dog: Dog = Dog()
print("Dog:  ", dog.speak())  # Output: Woof!

lion: Lion = Lion()
print("Lion: ", lion.speak())  # Output: Roar!

"""## **Duck Typing**

<br>

Duck typing is a fundamental concept in Python programming that enables developers to write flexible and dynamic code. It's a key aspect of Python's philosophy, **`which emphasizes "we are all consenting adults here" and encourages a more relaxed approach to programming`**.

<br>


**What is duck typing?**

Duck typing is a concept in programming that `focuses on the capabilities of an object` rather than its type. The idea is that if an object has the attributes and methods you need, you can use it as if it were of the type you expected, even if it's not. This approach is often summarized by the phrase "`if it walks like a duck and talks like a duck, it's a duck`."

<br>

**How does duck typing work in Python?**

In Python, `duck typing is the default behavior`. When you call a method or access an attribute on an object, `Python doesn't check the object's type beforehand. Instead, it tries to perform the operation and will only raise an error if the object doesn't have the required method or attribute`.

Here's an example of duck typing using a speaking parrot that talks like a human:

<br>

**Imagine you have a speaking parrot named Polly**

Polly can talk like a human, and you want to have a conversation with her. But you also want to have conversations with other humans.

<br>


**Let's say you write a function called `have_conversation`**

This function takes an object as a parameter, and it expects that object to have a `speak` method. Here's what the code might look like:
"""

class Human:
    def speak(self):
        print("Human: I'm good, thanks!")

class Parrot:
    def speak(self):
        print("Parrot: Polly wants a cracker!")

def have_conversation(person: Human):
    print("\nhave_conversation: Hello, how are you? ", type(person))
    person.speak()
"""

human = Human()
parrot = Parrot()

have_conversation(human)   # I'm good, thanks!
have_conversation(parrot)  # Polly wants a cracker!

"""In this example, the `have_conversation` function doesn't care whether it's talking to a human or a parrot. As long as the object has a `speak` method, it can have a conversation with it.

<br>

**This is like duck typing**

The `have_conversation` function is like a duck that says, "If it talks like a human, it's a human!" And because the parrot can talk like a human, it can have a conversation with the function.

<br>

**But here's the cool thing about duck typing**

You can add new types of objects that can have conversations, and the `have_conversation` function will still work with them. For example, you could create a `Robot` class that also has a `speak` method:
"""

class Robot:
    def speak(self):
        print("Robot: Beep boop, I am functioning within normal parameters!")

robot = Robot()
have_conversation(robot)  # Beep boop, I am functioning within normal parameters!

"""The `have_conversation` function doesn't need to know anything about the `Robot` class, because it only cares about the `speak` method. This makes it easy to add new types of objects to the conversation, without having to change the underlying code."""
